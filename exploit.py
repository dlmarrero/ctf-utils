#!/usr/bin/env python
from pwn import *
from sys import argv, exit


def main():
    io.interactive()


def set_bp(*args):
    gdbscript = ''
    for breakpoint in args:
        if type(breakpoint) == str:
            gdbscript += 'b %s\n' % breakpoint
            continue
        elif type(breakpoint) == tuple:
            addr, cmd_list = breakpoint
            assert type(cmd_list) == list

            bp_cmds = 'commands\n'
            bp_cmds += '\n'.join(cmd_list)
            bp_cmds += '\nend\n'
        else:
            addr = breakpoint
            bp_cmds = ''

        gdbscript += 'bp 0x%x\n%s' % (addr, bp_cmds)

    if args:
        gdbscript += 'c'

    gdb.attach(io, gdbscript)


class BlkROP(ROP):
    def find_gadget(self, insns):
        if type(insns) is str:
            insns = [insn.strip() for insn in insns.split(';')]

        found_gadget = super(BlkROP, self).find_gadget(insns)

        if not found_gadget:
            raise Exception('Gadget %s not found' % insns)

        log.debug('ROP 0x%x %s' % (found_gadget.address, ' ; '.join(found_gadget.insns)))
        return found_gadget

    def common(self):
        gadgets = {
            'pop_rdi': self.find_gadget('pop rdi').address,
            'pop_rsi': self.find_gadget('pop rsi').address,
            'pop_rdx': self.find_gadget('pop rdx').address
        }
        
        return gadgets


if __name__ == "__main__":
    if len(argv) == 1:
        print("Provide either <path_to_binary> or <ip> <port>")
        exit(1)

    if len(argv) > 2:
        ip, port = argv[1:3]
        io = remote(ip, port)
    else:
        binary = argv[1]
        io = process(binary)

    main()
